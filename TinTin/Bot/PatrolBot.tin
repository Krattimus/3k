#showme READING PATROLLER

#class {patroller} {open}

/*********************************************************
	Bot Data
*********************************************************/
#var shouldKill {}
#var attacking 0;
#var patrolling 0;
#var canWalk 1;
#var deadManCount 0;

/*********************************************************
	Events
*********************************************************/
.registerEvent onKilledMob onMobDiedCyclerResponder;
.registerEvent onWimpy onWimpyCycleResponder;
.registerEvent onFailedAttack onFailedAttackCycleResponder;
.registerEvent onRoomSeen onRoomSeenCycleResponder;
.registerEvent onFailedMovement onFailedMovementCyclerResponder;
.registerEvent onDebugLog onDebugLogCycleResponder;
.registerEvent onRequestStop requestStopPatroller;
.registerEvent onRequestResume requestResumePatroller;
.registerEvent onPathFinished onPathFinishedPatrolResponder;

#event {CLASS DESTROYED patrolbot}
{
	.unregisterEvent onKilledMob onMobDiedCyclerResponder;
	.unregisterEvent onMonsterFound onMonsterFoundCycleResponder;
	.unregisterEvent onWimpy onWimpyCycleResponder;
	.unregisterEvent onFailedAttack onFailedAttackCycleResponder;
	.unregisterEvent onFailedMovement onFailedMovementCyclerResponder;
	.unregisterEvent onDebugLog onDebugLogCycleResponder;
	.unregisterEvent onRequestStop requestStopPatroller;
	.unregisterEvent onRequestResume requestResumePatroller;
};

#alias onDebugLogCycleResponder
{
	.showHeader Patroller;
	.showSetting {Should Kill} "$shouldKill";
	.showSetting {Is Attacking} $attacking;
	.showSetting {Is Patrolling} $patrolling;
	.showSetting {Can Walk} $canWalk;
	.showSetting {Area} "$patrol[area]";
	.showSetting {Started At} "$patrol[startedAt]";
	.showSetting {Anchored} "$patrol[anchored]";
};

/***********************************************************
	Heart beat, every .1 second run our decision making
	tree
***********************************************************/
#ticker {patrolHeartBeat} 
{
	#NOP { Is the patrol bot active ? };
	#if { $patrolling }
	{
		.determineState;

		#NOP { Are we by ourselves? };
		#if { !$playerFound }
		{
			#NOP { If there is a mob that should be killed, attack it };
			#if { $mobFound && "$shouldKill" != "" }
			{
				.doBehaviorAttack;
			};
			#elseif { $canWalk }
			{
				.doBehaviorPatrol;
			}
		};
		#NOP { There are other players here, we should just move along};
		#else
		{
			.doBehaviorPatrol;
		};
	};
} {0.5};

/************************************************************
	DetermineState
		This is called after all the data collection
		has been given and before the state machine runs.
		It lets us add logic to correct assumptions from data.
		For example: If we are told not to walk because a mob
		 	was found... But, what if the mob isn't what
			we were suppose to kill?
************************************************************/
#alias .determineState 
{
	#if { $attacking }
	{
		#undelay {decisionStall};
		#var canWalk 0;
	};
	#else
	{
		#NOP { We see mobs since our last update };
		#if { !$playerFound && $mobFound && "$shouldKill" != "" }
		{
			#var canWalk 0;
		};
	};

	#NOP { We were attacked since our last update };
	#if { $playerAttacked }
	{
		#NOP { We can do several things here, kill it, flee, stop the patrol, etc... };
		#var canWalk 0;
		#var attacking 1;
	}
};

/************************************************************
	Behavior Attack: kill mob
************************************************************/
#alias .doBehaviorAttack
{
	#if { !$attacking }
	{
		#undelay {decisionStall};
		#var attacking 1;
		#var canWalk 0;
		#var deadManCount = 0;
		#send !kill $shouldKill;
	};
};

/************************************************************
	Behavior Patrol: Walk the path
************************************************************/
#alias .doBehaviorPatrol
{
	#undelay {decisionStall};
	#var deadManCount 0;
	#var canWalk 0;
	#path walk;
}

/************************************************************
	Between the time we decided to kill, and and time we
	tried to kill, we moved or the mob moved. Therefore
	we should no longer mark ourselves as trying to attack
	and shoudl look around to re-establish
************************************************************/
#alias onFailedAttackCycleResponder
{
	#var attacking 0;

	#if { $patrolling }
	{
		glance;
	};
};

/***********************************************************
    We tried moving somewhere and it was blocked, this
	probalby shouldn't happen in a patrol logic, so just 
	stop. Perhaps even 'go home'
***********************************************************/
#alias onFailedMovementCyclerResponder
{
	#if { $patrolling }
	{
		#echo {<202> Patrol Stopped Due To Failed Movement <088>};
		#var patrolling 0;
		.triggerEvent onPatrolStopped;
	};
};

/***********************************************************
	We wimpyed
***********************************************************/
#alias onWimpyCycleResponder
{
	#if { $patrolling }
	{
		#echo {<202> Patrol Stopped Due To Wimpy <088>};
		#var patrolling 0;
		.triggerEvent onPatrolStopped;
	};
};

/***********************************************************
	A mob died, lets take a look around
***********************************************************/
#alias onMobDiedCyclerResponder
{	
	#var shouldKill {};
	#var mobFound 0;
	#var attacking 0;

	#if { $patrolling }
	{
		#delay {0.2} { glance; };
	};
};

/***********************************************************
	We are being attacked, stop and look
***********************************************************/
#alias onPlayerAttackedCyclerResponder
{
	#var canWalk 0;
	#var attacking 1;

	#if { $patrolling }
	{
		glance;
	};
};

/***********************************************************
	Does a stall check, if for whatever reason, our 
	data doesn't match the world and we DON'T catch it,
	or if a decision hits an unforseen case, then this
	stall check will check again. If we can make a decision
	the check is stopped. So either a stallCheck goes or
	a decisionGoes. If we stall more than 4-5 times, something
	is wrong and we don't know what to do, so deadman the patrol
***********************************************************/
#alias .doStallCheck
{
	#delay {decisionStall} 
	{
		#math {deadManCount} {$deadManCount+1};
		#if { $deadManCount == 5 }
		{
			#undelay {decisionStall};
			#echo {<202> Patrol Stopped Due to Indecision <088>};
			#var patrolling 0;
			.triggerEvent onPatrolStopped;
		};
	
		glance;
	} {30};
};

/***********************************************************
	Allow movement again only until we see a room again
	Ideally, it wouldn't be until a room was seen AND a
	prompt was received, but sometimes the fast movement
	back buffers the prompt outputs, and you may get 
	multiple outputs, so this is a better truth for movement
***********************************************************/
#alias onRoomSeenCycleResponder
{
	#if { $patrolling }
	{
		.doStallCheck;
		#var canWalk 1;
	}
};

/***********************************************************
	The loaded patrol has been finished!
***********************************************************/
#alias onPathFinishedPatrolResponder
{
	#if { $patrolling }
	{
		#echo {<202> Patrol Stopped Due to Completion <088>};
		#undelay {decisionStall};
		#var patrolling 0;
		.mapAnchor;
		#var patrol[anchored] $mapAnchor;
		.triggerEvent patrolFinished;
	};
};

/*********************************************************
	Loads a patrol, called when it arrives at an area
	that was designated to be patrolled
*********************************************************/
#alias {.loadPatrol %1} 
{
	#echo {<202> Loading Patrol for [%1] <088>};

	.unregisterEvent onMonsterFound onMobAreaResponder;

	#map get {roomvnum} {startedAt};
	#read  3k/TinTin/Areas/%1.tin;

	#var patrol[shouldStart] $patrolStart;
	#var patrol[startedAt] $startedAt;
	#var patrol[anchored] $startedAt;
	#var patrol[mapname] %1;
	#var patrol[area] $patrolArea;
	#var patrol[position] 0;
	
	#path load botpath;

	.showSettings;
};

/*********************************************************
	Sets the variables to begin patrolling
*********************************************************/
#alias {.startPatrol}
{
	#NOP "$patrolArea" == "$patrol[area]";
	#if { "$patrolStart" == "$patrol[startedAt]" }
	{
		#var deadManCount 0;
		#var canWalk 0;
		#var attacking 0;
		#var patrolling 1;
		#var currentController patrol;
		glance;
	};
	#else
	{
		#echo {<202> Patrol Start Cancelled, We are not in the right area <088>};
		.triggerEvent onPatrolStopped;
	}
};

/*********************************************************
	Stop doesn't necessarily 'stop', it just sets
	variables such that the patroller doesn't actively
	process. Perhaps a 'pause' is a better term, but I
	think people will think more like:  
		goPatrol, 
		stop patrolling,
		goSell,
		goMining,
		go back to patrolling
*********************************************************/
#alias {.stopPatrol}
{
	#echo {<202> Patrol Stopped <088>};

	#var patrolling 0;
	#var currentController none;
	.mapAnchor;

	#var patrol[anchored] $mapAnchor;
	#path save forward patrol[path];
	#path save position patrol[position];
};

/*********************************************************
	This is similar to start patrol, except that it
	uses the variables already filled in
*********************************************************/
#alias {.resumePatrol}
{
	#var mapAnchor $patrol[anchored];
	.mapReturn;
	
	#delay {3}
	{
		#echo {<202> Resuming Patrol <088>};

		#path load $patrol[path];
		#path goto $patrol[position];

		#var attacking 0;	
		#var patrolling 1;
		#var currentController patrol;
		glance;
	};
};

/*********************************************************
	Parent Controller telling us to stop
*********************************************************/
#alias requestStopPatroller
{
	#if { $patrolling }
	{
		.stopPatrol;
	};
};

/*********************************************************
	Parent is telling the controllers to resume
*********************************************************/
#alias requestResumePatroller
{
	#if { "$resumeController" == "patrol" }
	{
		.resumePatrol;
	}
};


#class {patroller} {close}
