#class {miner} open

#var miner[canWalk] 0;
#var miner[shouldMine] 1;
#var miner[shouldSpelunk] 1;
#var miner[beingAttacked] 1;
#var miner[isMining] 0;
#var miner[miningLevel] 1;
#var miner[position] 0;
#var miner[startedAt] 0;

#var miner[roomsSpelunked] 0;
#var miner[depositsFound] 0;
#var miner[mobsFound] 0;
#var miner[totalRooms] 0;
#var miner[roomsVisited] 0;
#var miner[matsGathered] 0;
#var miner[oreGathered] 0;

#var miner[mining] {copper bronze adamantium obsidian nethernium}

/*********************************************************
	Events
*********************************************************/
.registerEvent onDebugLog onDebugLogMinerResponder;
.registerEvent onRequestStop requestStopPatroller;
.registerEvent onPathFinished onPathFinishedMinerResponder;
.registerEvent onRoomSeen onRoomSeenMinerResponder;
.registerEvent onKilledMob onMobKilledMinerResponse;
.registerEvent onItemFound onItemFoundMinerResponse;

#event {CLASS DESTROYED miner}
{

};

#alias onDebugLogMinerResponder
{
	.showHeader Mining;
	#var miner;
};


/***********************************************************************
	Heart beat, every .1 second run our decision making tree
***********************************************************************/
#ticker {miningHeartBeat} 
{
	#NOP { Is the patrol bot active ? };
	#if { $miner[isMining] }
	{
		#if { !$miner[beingAttacked] }
		{
			#NOP { If there is a mob that should be killed, attack it };
			#if { $miner[shouldSpelunk] }
			{
				.doBehaviorSpelunk;
			};
			#elseif { $miner[shouldMine] }
			{
				.doBehaviorMine;
			};
			#elseif { $miner[canWalk] }
			{
				.doBehaviorWalkMine;
			};
			#else
			{
				#NOP {default};
			};
		};
	};
} {0.5};


#alias {.doBehaviorMine}
{
	#UNDELAY {decisionStall};
	#var miner[shouldMine] 0;
	#var miner[canWalk] 0;
	#send !mine;
}

#alias {.doBehaviorSpelunk}
{
	#UNDELAY {decisionStall};
	#var miner[shouldSpelunk] 0;
	#var miner[canWalk] 0;
	#var miner[shouldMine] 0;
	#send !spelunk;
	#math {miner[roomsSpelunked]} {$miner[roomsSpelunked]+1};
	.renderMiningPanel;
}

#alias .doBehaviorWalkMine
{
	#undelay {decisionStall};
	#var deadManCount 0;
	#var miner[canWalk] 0;
	#path walk;
	#math {miner[roomsVisited]} {$miner[roomsVisited]+1};
	.renderMiningPanel;
}
/***********************************************************
	Allow movement again only until we see a room again
	Ideally, it wouldn't be until a room was seen AND a
	prompt was received, but sometimes the fast movement
	back buffers the prompt outputs, and you may get 
	multiple outputs, so this is a better truth for movement
***********************************************************/
#alias onRoomSeenMinerResponder
{
	#if { $miner[isMining] }
	{
		.doMinerStallCheck;
 		#var miner[shouldSpelunk] 1;
	}
};

/***********************************************************
	Does a stall check, if for whatever reason, our 
	data doesn't match the world and we DON'T catch it,
	or if a decision hits an unforseen case, then this
	stall check will check again. If we can make a decision
	the check is stopped. So either a stallCheck goes or
	a decisionGoes. If we stall more than 4-5 times, something
	is wrong and we don't know what to do, so deadman the patrol
***********************************************************/
#alias .doMinerStallCheck
{
	#delay {decisionStall} 
	{
		#math {deadManCount} {$deadManCount+1};
		#if { $deadManCount == 5 }
		{
			#undelay {decisionStall};
			#echo {<202> Mining Stopped Due to Indecision <088>};
			#var miner[isMining] 0;
			.triggerEvent onMiningStopped;
		};
	
		glance;
	} {30};
};

/***********************************************************************

***********************************************************************/
#alias {onItemFoundMinerResponse}
{
	#if { $miner[isMining] }
	{
		#if { @containsNoCase{{$lastItemFound}{deposit}} }
		{
			#var miner[shouldSpelunk] 0;
			#var miner[shouldMine] 1;
			#var miner[canWalk] 0;
		};
	};
} {2};

/***********************************************************************
	Load path based on which mine was entered
***********************************************************************/
#action {^You enter the mine shaft and hit the button for level %d$} 
{
	#if { $miner[isMining] }
	{
		#var miner[position] 0;

		#echo {<202> MINES ENTERED AT %1 <088>};
		#switch {%1} 
		{
			#case {1} { #map go 21683; #var miner[path] {se;e;n;w;e;n;e;se;nw;w;s;s;e;w;s;se;sw;e;e;w;w;s;s;n;n;ne;nw;sw;w;w;n;s;e;sw;s;s;nw;n;w;s;n;e;s;se;n;n;ne;e;ne;n;w;nw;out}};
			#case {2} {#var miner[path] {se;e;n;w;e;n;e;se;nw;w;s;s;e;w;s;se;sw;e;e;w;w;s;s;n;n;ne;nw;sw;w;w;n;s;e;sw;s;s;nw;n;w;s;n;e;s;se;n;n;ne;e;ne;n;w;nw;exit}};
			#case {3} {#var miner[path] {n;n;w;w;se;nw;s;n;sw;ne;w;e;nw;se;n;e;e;n;w;n;n;w;w;s;nw;s;s;s;s;s;w;n;w;s;e;e;n;n;n;n;n;se;e;s;s;s;e;e;s;s;exit}};
			#case {4} {#var miner[path] {e;e;e;ne;ne;ne;s;s;s;e;e;w;w;w;w;w;se;se;se;n;n;s;s;ne;ne;ne;n;n;n;s;s;s;nw;nw;nw;sw;sw;sw;w;w;w;exit}};
			#case {5} {#var miner[path] {e;s;s;s;e;ne;ne;s;s;s;e;n;n;n;n;se;se;n;e;e;w;w;n;w;e;e;n;n;w;sw;w;w;nw;nw;w;s;s;s;w;exit}};
			#case {6} {#var miner[path] {w;w;w;s;w;n;s;s;s;sw;se;n;s;ne;nw;n;n;ne;n;w;w;w;n;n;s;e;e;e;n;e;e;s;w;s;e;s;e;exit}};
			#case {7} {#var miner[path] {se;e;n;e;e;e;e;s;w;w;s;e;s;e;s;s;w;w;w;n;n;e;s;n;w;s;s;e;e;e;e;e;e;n;n;w;s;n;e;s;s;w;w;w;n;n;e;n;e;n;w;w;n;w;w;w;w;w;s;nw;exit}};
			#case {8} {#var miner[path] {s;se;sw;sw;n;n;s;s;nw;nw;ne;e;e;n;exit}};
		};

		#var miner[roomsSpelunked] 0;
		#var miner[depositsFound] 0;
		#var miner[mobsFound] 0;
		#var miner[roomsVisited] 0;
		#var miner[matsGathered] 0;
		#var miner[oreGathered] 0;
		.renderMiningPanel;
		#var deadManCount 0;
		#var miner[canWalk] 1;
		#path load miner[path];
		#path {GET} {LENGTH} {miner[totalRooms]};		
	};
}

#alias {onMobKilledMinerResponse}
{
	#if { $miner[isMining] }
	{
		#var miner[beingAttacked] 0;
		.doMinerStallCheck;
	};
};

/***********************************************************************
	
***********************************************************************/
#alias requestStopPatroller
{
	#if { $miner[isMining] }
	{
		.stopMining;
	};
};

/***********************************************************************
	stop
***********************************************************************/
#alias {.stopMining}
{
	#echo {<202> Mining Stopped <088>};

	#var miner[isMining] 0;
	#var currentController none;
	.mapAnchor;

	#var patrol[anchored] $mapAnchor;
	#path save forward miner[path];
	#path save position miner[position];
};

/***********************************************************************
	Load path based on which mine was entered
***********************************************************************/
#alias {.startMining}
{
	#map get {roomvnum} {miner[startedAt]};

	#NOP "$patrolArea" == "$patrol[area]";
	#if { $miner[startedAt] == 40 }
	{
		#showme {<202> Mines Level to $miner[miningLevel]  <088>};
		.showSettings; 

		#var deadManCount 0;
		#var miner[canWalk] 1;
		#var miner[beingAttacked] 0;
		#var miner[shouldSpelunk] 1;
		#var miner[shouldMine] 1;
		#var miner[isMining] 1;
		#var currentController miner;
		#send mines $miner[miningLevel];
	};
	#else
	{
		#echo {<202> Patrol Start Cancelled, We are not in the right area <088>};
		.triggerEvent onMiningStopped;
	}
};

#action {^You have successfully gathered some}
{
	#math {miner[oreGathered]} {$miner[oreGathered]+1};
	.renderMiningPanel;
};


#action {^You found %1 hidden inside!!}
{
	#math {miner[matsGathered]} {$miner[matsGathered]+1};
	.renderMiningPanel;
};

/* Deposit Found logic */
#action {^You have found a deposit of %1 ore!} 
{
	#math {miner[depositsFound]} {$miner[depositsFound]+1};
	.renderMiningPanel;
	#var miner[shouldMine] 1;
} {1};

/* Empty room logic */
#action {^You have found nothing.} 
{
	#var miner[shouldMine] 0;
}

/* Searched room logic */
#action {^It appears this part of the shaft has already been searched.} 
{
	#var miner[shouldSpelunk] 0;
	#var miner[canWalk] 1;
}

/* Mining complete logic */
#action {^You have exhausted the supply of %w ore.$} 
{
	#send get all;
	#var miner[shouldMine] 0;
	#var miner[canWalk] 1;
}

/* Spelunk with deposit present */
#action {^There is already a deposit here!} 
{
	#var miner[shouldSpelunk] 0;
	#var miner[shouldMine] 1;
}

/* Mob active logic */
#action {^You cannot spelunk while you're being attacked!} 
{
	#var miner[shouldSpelunk] 1;
	#var miner[beingAttacked] 1;
}

#action {^You have disturbed} 
{
	#var miner[beingAttacked] 1;
	#math {miner[mobsFound]} {$miner[mobsFound]+1};
	.renderMiningPanel;
}

#alias {onPathFinishedMinerResponder}
{
	#echo {<202> Mining Stopped due to completion <088>};
	#var miner[isMining] 0;

} {1};

#action {^You hop in the exit chute and fly out of the mine shaft!} 
{
	#echo {<202> Mining Stopped due to leaving mine <088>};
	#var miner[isMining] 0;
};


#alias {showmines} 
{
	#echo {Mine 1: copper};
	#echo {Mine 2: bronze};
	#echo {Mine 3: iron, steal};
	#echo {Mine 4: silver, gold, mithril};
	#echo {Mine 5: titanium, ebon};
	#echo {Mine 6: adamantium, obsidian};
	#echo {Mine 7: nethernium, boidstone, phasemetal};
	#echo {Mine 8: chaostone}
}

#class {miner} close
